#!/usr/bin/env python3

# 2014 - Dan Spencer
# This program is licensed under the BSD License. See LICENSE for details.
# genconst.py - Generate constants declarations for use in many programming
#               languages, including Java, MySQL, and JavaScript.

desc = """
Generate constants declaration for use in many programming
languages, including Java, MySQL, and JavaScript.
"""

def constants_test():
    return {"Something": {"Foo": 5, "Bar": 10}, "Else": {"Foo": {"Bar": 6}}};

def parse_constants(input):
    # We want ordered dictionaries, or else Python changes the order on
    # run-time (order is not deterministic!).
    # It'd be confusing if, say, the git log showed the entire output changing
    # when a single item was added just because the output order got shuffled.
    from collections import OrderedDict
    root = OrderedDict()
    
    parent_stack = [(0,root)]
    last = None
    current_children_list = []
    
    def add_parent():
        name = current_children_list.pop()
        flush_children()
        items = OrderedDict()
        parent_stack[-1][1][name] = items
        parent_stack.append((0,items))
    
    def pop_parent():
        flush_children()
        parent_stack.pop()
    
    def flush_children():
        def add_child_value(child):
            # Possible values for child:
            # KEY
            # KEY: VALUE
            p = [x.strip() for x in child.split(':') if x.strip()]
            enum, d = parent_stack[-1]
            if len(p) == 0:
                # Do nothing
                pass
            elif len(p) == 1:
                # No value - auto-increment enum
                enum,items = parent_stack[-1]
                parent_stack[-1] = (enum+1, items)
                key, value = p[0], enum
                
                items[key] = value
            elif len(p) == 2:
                # key/value
                key, value = p
                value = eval(value)
                items = parent_stack[-1][1]
                parent_stack[-1] = (value+1, items)
                
                items[key] = value
            else:
                raise Exception("Too many args: Line {0}".format(linenum))
            
        nonlocal current_children_list
        
        for x in current_children_list:
            add_child_value(x)
        
        current_children_list = []
    
    linenum = 0
    for line in input:
        linenum += 1
        # TODO - allow any sort of indentation (like Python does)
        # replace 4 spaces with tab
        line = line.replace("    ", "\t");
        # Parse out comments
        try:
            comment = line.index('#')
            line = line[0:comment]
        except ValueError:
            # No comment on the line
            pass
        
        # XXX - This is a hack, very breakable!
        list = [x.strip() for x in line.split('\t')];
        
        item = list[-1]
        
        indent = len(list)-1 - (len(parent_stack)-1)
        
        # Allowable indents: <-1, 0, +1
        if indent < 0:
            for x in range(-indent):
                pop_parent()
        elif indent == 1:
            add_parent()
        elif indent == 0:
            pass
        else:
            raise Exception("Cannot indent that much! Line {0}".format(linenum))
            
        current_children_list.append(item)

    flush_children()
    return root

def java_generator(table, name, output):
    def write_indent(indent):
        print('\t'*indent, file=output, end="");
    
    def write_value(indent, name, value):
        if isinstance(value, int):
            write_indent(indent);
            print("public static final int {0}={1};".format(name, value), file=output);
        elif isinstance(value, dict):
            write_indent(indent);
            print("public static final class {0} {{".format(name), file=output);
            write_values(indent+1, value);
            write_indent(indent);
            print("}", file=output);
        else:
            raise Exception("Unexpected type: " + type(value))
        
    def write_values(indent, values):
        for k in values:
            v = values[k];
            write_value(indent, k, v);

    print("""/*
 * This file was generated by genconst.py. DO NOT MODIFY!
 */""", file=output);
    
    print("public final class {0} {{".format(name), file=output);
    write_values(1, table);
    print("}", file=output);

def mysql_generator(table, name, output):
    def write_value(name, value):
        if isinstance(value, int):
            print("SET @{0}={1};".format(name, value), file=output);
        elif isinstance(value, dict):
            write_values(name, value);
        else:
            raise Exception("Unexpected type: {0}".format(type(value)))
        
    def write_values(name, values):
        for k in values:
            v = values[k];
            write_value(name+"."+k, v);

    print("""/*
 * This file was generated by genconst.py. DO NOT MODIFY!
 */""", file=output);
    write_values(name, table);

def js_generator(table, name, output):
    pass

langs = {
    'java': java_generator,
    'mysql': mysql_generator,
    'js': js_generator};

def main():
    import argparse
    import sys

    parser = argparse.ArgumentParser(description=desc)

    parser.add_argument('source', help='The constants source file, or - for stdin')
    parser.add_argument('namespace', help='The root name assigned to the constants')
    parser.add_argument('lang', help='The programming language of the output to be generated')
    parser.add_argument('output', help='The generated file destination, or - for stdout')

    args = parser.parse_args();

    if args.lang in langs:
        if args.source == "-":
            table = parse_constants(sys.stdin)
        else:
            with open(args.source, 'r') as input:
                table = parse_constants(input);
        
        if args.output == "-":
            langs[args.lang](table, args.namespace, sys.stdout);
        else:
            with open(args.output, 'w') as output:
                langs[args.lang](table, args.namespace, output);
    else:
        print("Language not supported: " + args.lang);

if __name__ == "__main__":
    main()

