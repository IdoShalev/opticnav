package opticnav.ardd;

import java.io.IOException;

import opticnav.ardd.protocol.ConfCode;
import opticnav.ardd.protocol.PassCode;
import opticnav.ardd.protocol.Protocol;
import opticnav.ardd.protocol.consts.ARDdARDProtocol;

import org.apache.commons.math3.random.RandomGenerator;
import org.apache.commons.math3.util.Pair;

/**
 * ARDListsManager manages the collection of ARD-related lists used by the application.
 * In cases where multiple lists need to cooperate (such as registering a device, which uses ARDPendingList and
 * ARDPersistedList), methods are placed in this class.
 * 
 * @author Danny Spencer
 * 
 */
public final class ARDListsManager {
    private final ARDPendingList pending;
    private final ARDPersistedList persisted;
    private final ARDConnectedList connected;
    private final RandomGenerator randomGen;
    private final InstancesList instances;

    /**
     * Construct the lists manager using the lists.
     * 
     * @param pending The pending list
     * @param persisted The persisted list
     * @param connected The connected devices list
     * @param instances The instances list
     * @param randomGen The random number generator used for generating confCodes and passCodes
     */
    public ARDListsManager(ARDPendingList pending, ARDPersistedList persisted,
            ARDConnectedList connected, InstancesList instances,
            RandomGenerator randomGen) {
        this.pending = pending;
        this.persisted = persisted;
        this.connected = connected;
        this.instances = instances;
        this.randomGen = randomGen;
    }

    public ARDPersistedList getPersistedList() {
        return this.persisted;
    }

    public ARDConnectedList getConnectedList() {
        return this.connected;
    }

    public InstancesList getInstancesList() {
        return this.instances;
    }
    
    /**
     * Generate a PassCode/ConfCode pair, used for registration.
     * 
     * @return A PassCode/ConfCode pair, and a BlockingValue that unblocks when the device is registered.
     */
    public Pair<Pair<PassCode, ConfCode>, BlockingValue<Integer>> generatePassConfCodes() {
        byte[] confCodeBytes, passCodeBytes;
        ConfCode confCode;
        PassCode passCode;
        
        confCodeBytes = new byte[Protocol.CONFCODE_BYTES];
        passCodeBytes = new byte[Protocol.PASSCODE_BYTES];
        
        synchronized (this.pending) {
            // generate confcode
            // confcode must not already exist in pending list
            do {
                this.randomGen.nextBytes(confCodeBytes);
                confCode = new ConfCode(confCodeBytes);
            } while (this.pending.containsConfCode(confCode));

            // generate passcode
            // passcode must not already exist in persisted or pending list
            synchronized (this.persisted) {
                do {
                    this.randomGen.nextBytes(passCodeBytes);
                    passCode = new PassCode(passCodeBytes);
                } while (this.pending.containsPassCode(passCode) ||
                        this.persisted.containsPassCode(passCode));
            }
            
            // add to pending
            Pair<Pair<PassCode, ConfCode>, BlockingValue<Integer>> codes;
            BlockingValue<Integer> result = new BlockingValue<>();
            
            codes = new Pair<>(new Pair<>(passCode, confCode), result);
            this.pending.addPassConfCodes(codes);
            return codes;
        }
    }
    
    /**
     * Find the device with the matching confirmation code and move it from ARDPendingList to ARDPersistedList.
     * 
     * @param confCode The confirmation code provided
     * @return A new ARD ID generated by persistence, or ARDdARDProtocol.NO_ARD if the confCode couldn't be found.
     * @throws IOException
     */
    public int persistPendingWithConfCode(ConfCode confCode) throws IOException {
        synchronized (this.pending) {
            Pair<PassCode, BlockingValue<Integer>> pw;
            int ardID;
            
            pw = this.pending.getPasscodeWaitAndRemoveByConfcode(confCode);
            
            if (pw == null) {
                // could not find an entry with confCode
                return ARDdARDProtocol.NO_ARD;
            } else {
                synchronized (this.persisted) {
                    ardID = this.persisted.registerARD(pw.getFirst());
                }

                pw.getSecond().set(ARDdARDProtocol.ReqCodes.REGISTERED);

                return ardID;
            }
        }
    }
}
